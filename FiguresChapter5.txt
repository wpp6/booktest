
/*********************************************************/
/*********************************************************/
/*    Figure 5-11.  clks.h                               */
/*********************************************************/
/*********************************************************/

/**********************************************************************  MPLAB Harmony Application Header File  File Name:    clks.h***********************************************************************/#ifndef _CLKS_H#define _CLKS_H//********************************************************************// Section: Type Definitions - CLKS module//********************************************************************typedef enum{    /* Application's state machine's initial state. */    CLKS_STATE_INIT=0,    /* TODO: Define states used by the application state machine. */    CLKS_STATE_EVENT,    CLKS_STATE_IDLE} CLK_STATES;typedef struct{    CLK_STATES clkstate;   // the current state    int idlecnt;   // counts the number of times in the CLKS_STATE_IDLE    unsigned int cpucycles;  // records the CPU cycles every second    unsigned int last_CP0;  // the last core timer count    int idlecntpersec;      // the idle count at the end of every second} CLKDATA;typedef struct{    int ticks;          // counts timer interrupts    int timeout;        // number of ticks for timeout    void (*action)();	// the method to execute when a timeout occurs} SUBCLK;//********************************************************************// Section: Application Initialization and State Machine Functions//********************************************************************void CLKS_Initialize ( void );  // This routine is called from APPS_Initialize() void CLKS_SM( void );    // This routine is called from APP_Tasks()void clk1000(void);      // the 1-second clockvoid clk100(void);       // the 100 msecond clock#endif /* _CLKS_H */

/* ============================================================================*/
//      End Figure 5-11.
/* ============================================================================*/

/*********************************************************/
/*********************************************************/
/*    Figure 5-13.  clks.c                               */
/*********************************************************/
/*********************************************************/

/********************************************************************  MPLAB Harmony Application Source File    File Name:    clks.c ********************************************************************/#include "app.h"#define LED4BLACK   {LED4B_Set();LED4G_Set();LED4R_Set();}#define LED4WHITE   {LED4B_Clear();LED4G_Clear();LED4R_Clear();}#define LED4RED     {LED4B_Set();LED4G_Set();LED4R_Clear();}#define LED4GREEN   {LED4B_Set();LED4G_Clear();LED4R_Set();}#define LED4BLUE    {LED4B_Clear();LED4G_Set();LED4R_Set();}#define LED4YELLOW  {LED4B_Set();LED4G_Clear();LED4R_Clear();}#define LED4MAGENTA {LED4B_Clear();LED4G_Set();LED4R_Clear();}#define LED4CYAN    {LED4B_Clear();LED4G_Clear();LED4R_Set();}//********************************************************************// Section: Global Data Definitions//********************************************************************extern APPDATA appData;CLKDATA clkData;SUBCLK clkCfg[] = {// ticks, timeout, action routine{ 0, 1000, clk1000},{ 0, 100,  clk100},{ 0, 0, NULL}};//********************************************************************// Section: Application Callback Functions//********************************************************************void TMR_CallbackFn (uint32_t status,uintptr_t context );void TMR_CallbackFn (uint32_t status,uintptr_t context ){    /* this will only happen after the timer is started */    clkData.clkstate = CLKS_STATE_EVENT; }//********************************************************************// Section: Application Initialization and State Machine Functions//********************************************************************void CLKS_Initialize ( void ){        clkData.cpucycles = 0;    clkData.last_CP0 = 0;    clkData.idlecnt = 0;    clkData.idlecntpersec = 0;    clkData.clkstate = CLKS_STATE_INIT;     }#define PERIODMS  99999     // microseconds*100 = 1  ms for a 100 MHz CPUvoid CLKS_SM ( void ){    SUBCLK *p;		// ptr to a SUBCLK object    switch(clkData.clkstate)    {        case CLKS_STATE_INIT:            // Register the timer callback function             TMR2_Stop();            TMR2_CallbackRegister(TMR_CallbackFn, NULL);                            TMR2_PeriodSet(PERIODMS); // Set the period (ms)                            TMR2_Start();           // Start the timer                        LogMsg("The 1 millisecond timer has started");            clkData.clkstate = CLKS_STATE_IDLE;             break;                    case CLKS_STATE_EVENT:            // update the msec counter used in LogMsgs            appData.msec_cnt++;                        // check all the clock timers             // execute an action if a timeout occurred            for(p = clkCfg; p->timeout > 0; p++)            {                p->ticks++;                if(p->ticks >= p->timeout)                {                    p->action();   // execute this routine                    p->ticks = 0;                }            }            clkData.clkstate = CLKS_STATE_IDLE;             break;                   case CLKS_STATE_IDLE:    // count the number of times through this loop            clkData.idlecnt++;                                              break;                }}void clk1000(void){    static int substate;    clkData.cpucycles = _CP0_GET_COUNT() - clkData.last_CP0;   // cycles/sec    clkData.last_CP0 = _CP0_GET_COUNT();    // store the current value    clkData.idlecntpersec = clkData.idlecnt;    // store the idle counter    clkData.idlecnt = 0;                        // reset the idle counter    // cycle the multicolored LED through all the combos    substate++;    if(substate == 1) LED4WHITE    else if(substate == 2) LED4RED    else if(substate == 3) LED4GREEN    else if(substate == 4) LED4BLUE    else if(substate == 5) LED4YELLOW    else if(substate == 6) LED4CYAN    else if(substate == 7) LED4MAGENTA    else LED4BLACK    if(substate > 7) substate = 0;        // toggle the LEDs while button is not pressed    if(SW4_Get())      {        LED1_Toggle();        LED2_Toggle();        LED3_Toggle();    }            // update the global time variables    appData.unixsecs++;             // update the UNIX time by 1 second    appData.msec_cnt = 0;           // synch with the unixsecs update//  LogMsg("One second elapsed");   // add a log message to the circular buffer  }// routine to monitor the each switch and set the associated LED accordinglyvoid clk100(void){    if(!SW1_Get())  LED1_Toggle();    if(!SW2_Get())  LED2_Toggle();    if(!SW3_Get())  LED3_Toggle();    if(!SW4_Get())      {        LED1_Set();     // OFF        LED2_Set();     // OFF        LED3_Set();     // OFF    }}/***************************************************************** End of File */

/* ============================================================================*/
//      End Figure 5-13.
/* ============================================================================*/


/*********************************************************/
/*********************************************************/
/*    Figure 5-14.  app.h Ð MZEF_base (Chapter 5)        */
/*********************************************************/
/*********************************************************/

/********************************************************************  MPLAB Harmony Application Header File  Company:    Microchip Technology Inc.  File Name:    app.h*********************************************************************/#ifndef _APP_H#define _APP_H#include <stdint.h>#include <stdbool.h>#include <stddef.h>#include <stdlib.h>#include <string.h>#include <stdio.h>#include <stdarg.h>#include "definitions.h"#include "configuration.h"#include "clks.h"#include "cdc.h"#ifdef __cplusplus  // Provide C++ Compatibilityextern "C" {#endif    #define MAXMSGS  50#define MSGCOLS  120#define BOY2015  1420070400UL	//UNIX time at 1/1/2015 00:00:00// *******************************************************************// Section: State Definitions and State Data// *******************************************************************typedef struct{    int msec_cnt;                   // used in LogMsg    unsigned int unixsecs;          // used in LogMsg    char logmessages[MAXMSGS][MSGCOLS+1]; // space for MAXMSGS messages    int msgput;                // index of next message to be added    int msgget;         // index of next message to write to a com port } APPDATA;#undef SYS_DEBUG_PRINT#define SYS_DEBUG_PRINT(level, fmt, ...)    do { if((level) <= SYS_ERROR_DEBUG) LogMsg(fmt, ##__VA_ARGS__); } while (0)#undef SYS_ERROR_PRINT#define SYS_ERROR_PRINT(level, fmt, ...)    do { if((level) <= SYS_ERROR_DEBUG) LogMsg(fmt, ##__VA_ARGS__); } while (0)#undef SYS_ERROR#define SYS_ERROR(level,fmt, ...)   do { if((level) <= SYS_ERROR_DEBUG) LogMsg(fmt, ##__VA_ARGS__); } while (0)#undef SYS_CONSOLE_PRINT#define SYS_CONSOLE_PRINT(fmt, ...)    do { LogMsg(fmt, ##__VA_ARGS__); } while (0)#undef SYS_CONSOLE_MESSAGE#define SYS_CONSOLE_MESSAGE(fmt, ...)    do { LogMsg(fmt, ##__VA_ARGS__); } while (0)typedef enum{    /* Errors that have the potential to cause a system crash. */    SYS_ERROR_FATAL     = 0,    /* Errors that have the potential to cause incorrect behavior. */    SYS_ERROR_ERROR     = 1,    /* Warnings about potentially unexpected behavior or side effects. */    SYS_ERROR_WARNING   = 2,    /* Information helpful to understanding potential errors and warnings. */    SYS_ERROR_INFO      = 3,    /* Verbose information helpful during debugging and testing. */    SYS_ERROR_DEBUG     = 4} SYS_ERROR_LEVEL;// *******************************************************************// Section: Prototypes// *******************************************************************void APP_Initialize ( void );void APP_Tasks( void );void LogMsg(const char *format, ...);void get_dt(char *str);#endif /* _APP_H */#ifdef __cplusplus}#endif/******************************************************************** End of File */

/* ============================================================================*/
//      End Figure 5-14.
/* ============================================================================*/

/*********************************************************/
/*********************************************************/
/*    Figure 5-15.   app.c Ð MZEF_base (Chapter 5)       */
/*********************************************************/
/*********************************************************/

/*********************************************************************  MPLAB Harmony Application Source File  File Name:    app.c*********************************************************************/#include "app.h"APPDATA appData;// *****************************************************************// Section: Application Initialization and State Machine Functions// *****************************************************************void APP_Initialize ( void ){    appData.msec_cnt = 0;    appData.unixsecs = BOY2015;     // temporary for now       appData.msgget = 0;    appData.msgput = 0;    memset(appData.logmessages, 0, sizeof(appData.logmessages));}void APP_Tasks ( void ){}// *******************************************************************// Section: Application Local Functions// *******************************************************************#define DAYSECS	86400		// seconds per day#define YRSECS	DAYSECS*365	// seconds per yearint dmon[13] = {31,28,31,30,31,30,31,31,30,31,30,31,0};const char mond[12][4]={"JAN","FEB","MAR","APR","MAY","JUN", "JUL","AUG","SEP","OCT","NOV","DEC"};const char *badtime = "**-***-**** **:**:**.***";//*****************************************************************// Add a time tag and write a log message into the message buffer//*****************************************************************void LogMsg(const char *format, ...){    int len = 0;    char ascdt[28];			// constructed ascii time string    char tmpBuf[MSGCOLS+1];    char str[MSGCOLS-28];    memset(ascdt, 0, sizeof(ascdt));    memset(tmpBuf, 0, sizeof(tmpBuf));    memset(str, 0, sizeof(str));    get_dt(ascdt);    strcpy(tmpBuf, ascdt);    // prepend the current date/time    va_list args = (va_list){0};    va_start( args, format );    len = vsnprintf(str, MSGCOLS-28, format, args);    va_end( args );    if (len > 0 && len < MSGCOLS-28)    {        str[len] = '\0';        strncat(tmpBuf, str, MSGCOLS-28);	//do not overrun tmpBuf        strcat(tmpBuf,"\n\r");                strcpy(appData.logmessages[appData.msgput], tmpBuf);        appData.msgput++;        if(appData.msgput > (MAXMSGS-1)) appData.msgput = 0;  //rollover    }}void get_dt(char *str){	int yr, mon, dd, hh, mm, ss;	long tsecs;	int isecs, ysecs, dsecs;	int err;    char timenow[28];	err = 0;		// no error (yet)	mon=0;	yr=0;	isecs=0;    ysecs = 0;    dsecs = 0;    tsecs = 0;	memset(timenow,0,sizeof(timenow));    tsecs = appData.unixsecs;	tsecs -= BOY2015;	// get the year, month, day	for(yr=2015,isecs=0; yr<2100; yr++)	{	    ysecs = YRSECS;            // adjust for leap year	    if((yr%4) == 0) {ysecs += DAYSECS; dmon[1]++;}		    if((isecs+ysecs) > tsecs)	// tsecs are in the current year	    {            tsecs -= isecs;            break; // found the current year	    }	    else isecs += ysecs;	// add a year and keep looking	}	if(yr > 2099)	{//	    LogMsg("Date/Time error finding the year");	    err = 1;	}	else	{	    for(mon=0,isecs=0; mon<12; mon++)	    {              dsecs = dmon[mon]*DAYSECS;              if((isecs + dsecs) > tsecs)              {                tsecs -= isecs;                break;              }              else isecs += dsecs;	// add a month and keep looking	    }	    if(mon > 11)	    {//            LogMsg("Date/Time error finding the month");              err = 1;	    }	}	// get the hh:mm:ss	dd = tsecs/DAYSECS;	tsecs -= (dd*DAYSECS);	dd++;                   // days start at 1	hh = tsecs/3600;	tsecs -= hh*3600;	mm = tsecs/60;	tsecs -= mm*60;	ss = tsecs;	if(ss < 0) err=1;	if(err) strcpy(timenow,badtime);	else	sprintf(timenow,"%02d-%s-%04d %02d:%02d:%02d.%03d ",	               dd,mond[mon],yr,hh,mm,ss,appData.msec_cnt);	// transfer the results back to the calling program	strcpy(str,timenow);	return;}/******************************************************************* End of File */

/* ============================================================================*/
//      End Figure 5-15.
/* ============================================================================*/


